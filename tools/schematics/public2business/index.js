var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// tools/schematics/public2business/index.ts
__export(exports, {
  MODULES: () => MODULES,
  public2business: () => public2business
});
var import_core = __toModule(require("@angular-devkit/core"));

// tools/schematics/bazel/format-bazel-file.ts
var import_child_process = __toModule(require("child_process"));
var import_crypto = __toModule(require("crypto"));
var import_fs = __toModule(require("fs"));
var import_os = __toModule(require("os"));
var import_path = __toModule(require("path"));
var { getNativeBinary } = require("@bazel/buildifier/buildifier");
function formatBazelFile(relativePath, content) {
  const tmpPath = (0, import_path.join)((0, import_os.tmpdir)(), `bazel_file_to_format_${(0, import_crypto.randomBytes)(32).toString("hex")}.bazel`);
  (0, import_fs.writeFileSync)(tmpPath, content, "utf8");
  const binary = getNativeBinary();
  (0, import_child_process.execSync)(`"${binary}" -path=${relativePath} "${tmpPath}"`);
  const result = (0, import_fs.readFileSync)(tmpPath, "utf8");
  (0, import_fs.unlinkSync)(tmpPath);
  return result;
}

// tools/schematics/public2business/index.ts
var AUTOGENERATED_FILES = {
  AUTOGENERATED_DO_NOT_MODIFY: "See schematics/public2business",
  ".gitignore": "*"
};
var MODULES = [
  "accordion",
  "autocomplete",
  "badge",
  "breadcrumb",
  "datepicker",
  "dropdown",
  "field",
  "form-field",
  "file-selector",
  "input",
  "loading",
  "option",
  "pagination",
  "radio-button",
  "select",
  "tabs",
  "textarea",
  "textexpand",
  "time-input",
  "usermenu"
];
function public2business(options) {
  return (tree) => {
    MODULES.filter((m) => !options || !options.filter || m === options.filter).forEach((m) => copyAndAdaptPublicModule(m));
    function copyAndAdaptPublicModule(moduleName) {
      const publicDir = tree.getDir(`src/angular-public/${moduleName}`);
      const businessDir = tree.getDir(`src/angular-business/${moduleName}`);
      businessDir.visit((path) => {
        if (path.endsWith(".spec.ts") || Object.keys(AUTOGENERATED_FILES).every((k) => !path.endsWith(k)) && !tree.exists((0, import_core.join)(publicDir.path, (0, import_core.relative)(businessDir.path, path)))) {
          tree.delete(path);
        }
      });
      publicDir.visit((path, entry) => {
        if (entry && !path.endsWith(".spec.ts")) {
          let targetPath = (0, import_core.join)(businessDir.path, (0, import_core.relative)(publicDir.path, path));
          if (targetPath.endsWith(".business.html")) {
            targetPath = targetPath.replace(".business.html", ".html");
          }
          const content = adaptFile(entry);
          if (hasBusinessVariant(path)) {
          } else if (!tree.exists(targetPath)) {
            tree.create(targetPath, content);
          } else if (tree.read(targetPath).toString() !== content) {
            tree.overwrite(targetPath, content);
          }
        }
      });
      Object.entries(AUTOGENERATED_FILES).forEach(([name, content]) => {
        const filePath = (0, import_core.join)(businessDir.path, name);
        if (!tree.exists(filePath)) {
          tree.create(filePath, content);
        }
      });
    }
    function hasBusinessVariant(path) {
      return path.endsWith("component.html") && tree.exists(path.replace(".html", ".business.html"));
    }
    function adaptFile(entry) {
      const autogenerated = "/** Autogenerated by public2business schematic. DO NOT CHANGE! */\n";
      const content = entry.content.toString("utf8");
      if (["md", "json", "html"].some((e) => entry.path.endsWith(`.${e}`))) {
        return content.replace("(/public/", "(/business/");
      } else if (entry.path.endsWith(".scss")) {
        return `${autogenerated}$sbbBusiness: true;

${content}`;
      } else if (entry.path.endsWith(".ts")) {
        return `${autogenerated}/* tslint:disable */
${content.replace("const isBusiness = false;", "const isBusiness = true;")}`.replace(/@sbb-esta\/angular-public/g, "@sbb-esta/angular-business");
      } else if (entry.path.endsWith(".bazel")) {
        const file = `# Autogenerated by public2business schematic. DO NOT CHANGE!
${content}`.replace(/public\//g, "business/").replace(/    "ng_test_library",\n/g, "").replace(/    "ng_web_test_suite",\n/g, "").replace(/deps = \[\n([ ]+)(("[^"]+",\n[ ]+){2,})\]/gm, (_f, space, deps) => {
          let newDeps = "deps = [\n";
          deps.match(/("[^"]+")/g).sort().forEach((d) => newDeps += `${space}${d},
`);
          return `${newDeps}${space.substring(4)}]`;
        }).replace(/\nng_test_library\([\w\W]+?ng_web_test_suite\([\w\W]+?(\r\n|\r|\n)\)\n/m, "");
        return formatBazelFile((0, import_core.relative)(tree.root.path, entry.path), file);
      } else {
        return `${autogenerated}${content}`;
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MODULES,
  public2business
});
